Al algoritmo de exito se le ah pedido que encuentre la mejor secuencia de transportes para ir del ECDMX, Hacia ZACATECAS y arrojo la siguiente propuesta
[CDMX][CHIHUAHUA][ZACATECAS]

se oberva que a solucon optiam (segun el objetivo que se ah definido) ya que aunque 3 conexiones hay otras soluciones psoibles no se encuentrara ninguna con menos de 3
para representar las conexiones se usa la estructura de datos llamada diccionario de oython que permite de manera sencilla representar todas las conexiones, A la hora de generar los nodos hijo solo se tiene que obtener los elementos almacenados en el diccionario que corresponde con la ciudad que se esta examinando.

BUSQUEDA DE PROFUNDIDAD
La busqueda en **Profundidad** o **Depth First Search (DFS)** recorre el arbol/grafo de forma diferente a la busqueda en apmlitud. En lugar de ir visitando todos los nodos, En lugar de ir visitando todos los nodos de un mismo nivel, va descendiendo hasta la maxima profundidad de la rama y cuando llega al nodo mas profundo continua con la siguiente rama

                                                     ___
                                                    |   |
                                                    |   |
                                                    |___|
                                 ____
                                |    |
                                |    |
                                |____|




Desde  el punt de vista de la implementacion la busqueda en profundidad se diferenci en apmlitud en que utiliza una pila LIFO(Last In Last Out), una pila LIFO tiene 2 operaciones, una par introducir un dato y otra para extraer un dato de la pila a difernecia de la cola el dato que se extrae de la pila, es el ultimo que se introdujo. 

Se puede imaginar como una pila de datos a una pila de paltos, Cada vez que se amontona uno quedara en la parte superior del monton, para tomar alguno siempre se tendra que tomar el que se encuentre en la parte superior es decir el ultimo que se agrego



Visiblemente el resultado es peor que el obtenido con la busqueda en amplitud, Esto indica que la entrada de esta busqueda no es optima como el caso de la busqueda en amplitud. se dice que es suboptima. otro problema que presenta el algoritmo es que si el arbol de busqueda no esta acotado en profundidad, es decir es definitivamente profundo nunca saldra de la primera rama.

En cuanto la complejidad temporal un arbol con profundidad no esta acotado en profundidad **p** tiene una complejidad **O(b^p)** Recordemos que la complejidad de busqueda en amplitud es O(b^p), donde d es la profundidad en la que se encuentra la solucion como en lamayoria de los casos p> d, se puede afirmar que la complejidad de la busqueda en profundidad sera para la mayoria de los casos mayor que la busqueda en amplitud igual). 

Por que presentar el entonces la busqueda de profundidad si parece no tener ninguna ventaja sobre la busqueda en amplitud deliveradamente no se ah hablado aun de la complejidad espacial en los pseudocodigos de ambas busquedas se ah usado una lista para almacenar los nodos visitados se ha hecho asi para no perder la generalidad y que el algoritmo fuera usable tanto en arboles como en grafos. Ahora bien si el espacio de busqueda esta descrito por un arbol y no por un grafo se puede precindir de una lista de nodos visitados, en la busqueda en profundidad, si el espacio de busqueda por un arbol la complejidad espacial se reduce a O(b^m) lo que supone un costo de almacenamiento muy inferior al usado en la busqueda en amplitud.

Eso es debido a que cuando se explora una rama sus nodods queda elimidados de la lista frontera. Mientras que la busqueda en amplitud es necesario mantener almacenados los nodos frontera de todas las ramas a la vez.

como medir los ciclos de reloj de un programa en python asjddasdjas

Para hacernos uan idea se tomara con ejemplo el Puzzle lineal. Se supone que un nodo necesita